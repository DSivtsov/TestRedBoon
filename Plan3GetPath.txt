interface IPathFinder
{
IEnumerable<Vector2> GetPath(Vector2 A, Vector2 C, IEnumerable<Edge> edges);
}

struct Rectangle
{
public Vector2 Min;
public Vector2 Max;
}
struct Edge
{
public Rectangle First;
public Rectangle Second;
public Vector3 Start;
public Vector3 End;
}

--------------------------OLDVariant----------------------------------

class LineMath
	float angle	//tangence = y/x
	Vector2 dot

class SolutionForDot	// lineA.dot.x =  lineB.dot.x
	LineMath	lineA
	LineMath	lineB	
	
class SolutionForEdge
	SolutionForDot dotA
	SolutionForDot	dotB 	//for horizontal edge lineA.dot.x <  lineB.dot.x for vertical lineA.dot.y <  lineB.dot.y 
	
--------------------------PrevVariant----------------------------------

class SolutionForDot	// angleLineB > angleLineA in degrees
	float	angleLineB
	float	angleLineA
	Vector2	dot	
	
class SolutionForEdge
	SolutionForDot dotA
	SolutionForDot	dotB 	//for horizontal edge lineA.dot.x <  lineB.dot.x for vertical lineA.dot.y <  lineB.dot.y 

class Step
	float angleTurn
	float lenghtStep

class Path
	Step[] steps
	Vector2[] stepDots
--------------------------CurrentVariant----------------------------------
class Solution	// angleLineB > angleLineA in degrees
	float	angleLineB
	float	angleLineA
	Vector2	dot	

ISolution
	IEnumerable<Solution> GetSolution()
	

class SolutionForDot : ISolution	// angleLineB > angleLineA in degrees
	Solution dotA	

class SolutionForEdge : ISolution
	Solution 	dotA
	Solution	dotB 	//for horizontal edge lineA.dot.x <  lineB.dot.x for vertical lineA.dot.y <  lineB.dot.y 
-------------------------//--------------------------------------------------
SolutionForDot GetFromDotSolution(Vector2) // for StartPath

bool rez = TryLinkSolutionWithDot(SolutionForDot, Vector2)

if rez = No
SolutionForDot EndPath = GetFromDotSolution(Vector2) // for EndPath
PathSolutions.Add(SolutionForDot StartPath)
idsxEdge Before SolutionForDot EndPath
Cycle internal:
	CurrentSolution = GetCurrentSolution
	
	Step[] path = TryLinkTwoSolutionDot(SolutionForDot CurrentSolution, SolutionForDot EndPath)
	
		if path != null
			PathSolution.Add(CurrentSolution)
			goto make FindStepPath from PathSolutions & path

		if path = null
			NUM - number Edges between Current Solution and SolutionForDot (for EndPath)]
			Cycle: X = 0  
				edge = GetEdgeFromEdges[idsxEdge - X]
				List<Solution> checkList = CurrentSolution.GetListSolutionToCheck
				//Can be checked only one Solution FindBest PossibleSoluition from  checkList
				foreach CheckedSolution in checkList 	
					Step step = TryLinkSolutionWithEdgeDonCrossBordersRect(CheckedSolution,edge)
					if step != null
						NewSolution.Add(step)
				if NewSolution.Count ==0 break internal Cycle //in case checkin all in list
					X++
					if X != NUM continue cycle
						else throw can find Path //Wouldn't link dots in one Rectangle
				if NewSolution.Count !=0
					PathSolution.Add(CurrentSolution)
					Goto Cycle internal
			EndCycle 

make FindStepPath from PathSolutions:
(IEnumerable<Vector2>) GetSteps (PathSolutions,path,SolutionForDot EndPath)

The Best Path from CurrentSolution to selectedEdge
	Find On selectedEdge find the Dot1 which more close to next Edge (to one from two its dots)
	Find On CurrentSolution find the dot which more close to Dot1

//Two variant GetPath:
- Store the Steps of Path in Process FindPath (more speed variant more prefer for Light objects)
- Store PathSolutions in proces FindPath and after "FindStepPath from PathSolutions:" more slowly but can give possibility to select the PATH with different demands (more long, less shartTurn, no go align walls and so on)
// (IEnumerable<Vector2>) will not include StartPath & EndPath

-------------------/In case if Rectangle will not only Horisontal & Vertical/--------------------

        //internal void LineCrossingEdge(Vector2 start, Vector2 end)
        //{
        //    //Demands get LineEdge from edge
        //    //Build Matrix2x2 with LineEdges and Line
        //    //Get Solution
        //    throw new NotImplementedException();
        //}

        //internal void TryIntersecLineWithEdge(int currentTestingNumEdge)
        //{
        //    Edge curentEdge = _arrEdges[currentTestingNumEdge];
        //    LineCrossingEdge(curentEdge.Start, curentEdge.End);
        //}